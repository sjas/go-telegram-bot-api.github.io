[{"uri":"https://go-telegram-bot-api.github.io/getting-started/","title":"Getting Started","tags":[],"description":"","content":"This library is designed to be very similar to working with the Bot API directly. It does not provide any methods or features than what the Bot API provides.\nLet\u0026rsquo;s start by building a bot that repeats each message it sees back to the user. First, make sure you\u0026rsquo;re at least somewhat familiar with how Telegram Bots work. You can find their documentation here.\nNext we need to make sure we have the latest version of the library installed.\ngo get -u github.com/go-telegram-bot-api/telegram-bot-api If V5 hasn\u0026rsquo;t been released yet and you\u0026rsquo;re using go 1.11, you can use modules to request the develop branch instead.\nexport GO111MODULES=on go get -u github.com/go-telegram-bot-api/telegram-bot-api@develop Now that we\u0026rsquo;ve got everything ready to go, we can open up a new file and start writing some code. We\u0026rsquo;ll start by creating a new BotAPI. Instead of hardcoding the token from @Botfather, we can use environment variables.\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;github.com/go-telegram-bot-api\u0026#34; ) func main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_APITOKEN\u0026#34;)) if err != nil { panic(err) // You should add better error handling than this!  } bot.Debug = true // Has the library display every request and response. } This code gets an environment variable named TELEGRAM_APITOKEN, initializes a new BotAPI, causes a panic if the token was missing or invalid, and enables debugging in the library. Enabling debug mode can be incredibly helpful to make sure each request and response looks like you\u0026rsquo;d expect.\nAfter that bit has been done, we need to keep asking Telegram for updates. While it is possible to have Telegram send your Bot webhooks instead, it\u0026rsquo;s much easier to get started with polling updates. The following code should go in the main function, below the bot.Debug line.\n// Create a new UpdateConfig struct with an offset of 0. // Future requests can pass a higher offset to ensure there aren\u0026#39;t duplicates. updateConfig := tgbotapi.NewUpdate(0) // Tell Telegram we want to keep the connection open longer and wait for incoming updates. // This reduces the number of requests that are made while improving response time. updateConfig.Timeout = 60 // Now we can pass our UpdateConfig struct to the library to start getting updates. // The GetUpdatesChan method is opinionated and as such, it is reasonable to implement // your own version of it. It is easier to use if you have no special requirements though. updates := bot.GetUpdatesChan(u) // Now we\u0026#39;re ready to start going through the updates we\u0026#39;re given. // Because we have a channel, we can range over it. for update := range updates { // There are many types of updates. We only care about messages right now,  // so we should ignore any other kinds.  if update.Message == nil { continue } // Because we have to create structs for every kind of request,  // there\u0026#39;s a number of helper functions to make creating common  // types easier. Here, we\u0026#39;re using the NewMessage helper which  // returns a MessageConfig struct.  msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text) // As there\u0026#39;s too many fields for each Config to specify in a single  // function call, we need to modify the result the helper gave us.  msg.ReplyToMessageID = update.Message.MessageID // We\u0026#39;re ready to send our message!  // The Send method is for Configs that return a Message struct.  // Sending Messages (among many other types) return a Message.  // In this case, we don\u0026#39;t care about the returned Message.  // We only need to make sure our message went through successfully.  if _, err := bot.Send(msg); err != nil { panic(err) // Again, this is a bad way to handle errors.  } } And there\u0026rsquo;s the basics of building your very own bot! You can see the entire code for this bot here along with many more examples.\n"},{"uri":"https://go-telegram-bot-api.github.io/examples/reply-bot/","title":"Reply Bot","tags":[],"description":"","content":"Reply Bot is one of the most simple bots you can make. It sends any message it sees as a reply to that message. A more detailed explanation of this bot is available on the getting started page.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-telegram-bot-api/telegram-bot-api\u0026#34; ) func main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_APITOKEN\u0026#34;)) if err != nil { log.Panic(err) } bot.Debug = true log.Printf(\u0026#34;Authorized on account %s\u0026#34;, bot.Self.UserName) u := tgbotapi.NewUpdate(0) u.Timeout = 60 updates, err := bot.GetUpdatesChan(u) for update := range updates { if update.Message == nil { // ignore any non-Message Updates \tcontinue } msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text) msg.ReplyToMessageID = update.Message.MessageID if _, err := bot.Send(msg); err != nil { log.Panic(err) } } }"},{"uri":"https://go-telegram-bot-api.github.io/examples/commands/","title":"Commands","tags":[],"description":"","content":"This bot has a very similar starting point to reply bot but handles basic commands instead of replying the same message.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-telegram-bot-api/telegram-bot-api\u0026#34; ) func main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_APITOKEN\u0026#34;)) if err != nil { log.Panic(err) } bot.Debug = true log.Printf(\u0026#34;Authorized on account %s\u0026#34;, bot.Self.UserName) u := tgbotapi.NewUpdate(0) u.Timeout = 60 updates := bot.GetUpdatesChan(u) for update := range updates { if update.Message == nil { // ignore any non-Message updates  continue } if !update.Message.IsCommand() { // ignore any non-command Messages  continue } // Create a new MessageConfig. We don\u0026#39;t have text yet,  // so we should leave it empty.  msg := tgbotapi.NewMessage(update.Message.Chat.ID, \u0026#34;\u0026#34;) // Extract the command from the Message.  switch update.Message.Command() { case \u0026#34;help\u0026#34;: msg.Text = \u0026#34;type /sayhi or /status.\u0026#34; case \u0026#34;sayhi\u0026#34;: msg.Text = \u0026#34;Hi :)\u0026#34; case \u0026#34;status\u0026#34;: msg.Text = \u0026#34;I\u0026#39;m ok.\u0026#34; default: msg.Text = \u0026#34;I don\u0026#39;t know that command\u0026#34; } if _, err := bot.Send(msg); err != nil { log.Panic(err) } } }"},{"uri":"https://go-telegram-bot-api.github.io/migrating-from-v4/","title":"Migrating from V4","tags":[],"description":"","content":" v5 introduces a number of backwards incompatible changes. The most major change is removing a number of functions that returned an APIResponse. As these functions had no specific return type, there was no reason to not use the Config directly with the newly introduced Request function.\nMajor Changes  Methods that returned an APIResponse were removed. Instead of using the previous function, you can switch to using the Request method with no further changes. For example, bot.SetWebhook(config) can be replaced with bot.Request(config). BotAPI.GetUpdatesChan no longer returns an error. As it was always nil, there is no reason to include it. There are no longer pointers to arrays, they were replaced with the array directly. MakeRequest now takes in a Params argument instead of url.Values. UploadFile now takes in a Params argument instead of map[string]string.  New Features  At the time of writing, every Telegram Bot API method and type is implemented. Any Config can be sent with Request.  Internal Library Improvements  Removed Chattable values() and just use Chattable params() instead. Using new Params type instead of a map or url.Values directly. This new type has a number of helper methods attached to it which greatly reduce the amount of boilerplate code for adding fields.  "},{"uri":"https://go-telegram-bot-api.github.io/examples/keyboard/","title":"Keyboard","tags":[],"description":"","content":"This bot shows a numeric keyboard when you send a \u0026ldquo;open\u0026rdquo; message and hides it when you send a \u0026ldquo;close\u0026rdquo;\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-telegram-bot-api/telegram-bot-api\u0026#34; ) var numericKeyboard = tgbotapi.NewReplyKeyboard( tgbotapi.NewKeyboardButtonRow( tgbotapi.NewKeyboardButton(\u0026#34;1\u0026#34;), tgbotapi.NewKeyboardButton(\u0026#34;2\u0026#34;), tgbotapi.NewKeyboardButton(\u0026#34;3\u0026#34;), ), tgbotapi.NewKeyboardButtonRow( tgbotapi.NewKeyboardButton(\u0026#34;4\u0026#34;), tgbotapi.NewKeyboardButton(\u0026#34;5\u0026#34;), tgbotapi.NewKeyboardButton(\u0026#34;6\u0026#34;), ), ) func main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_APITOKEN\u0026#34;)) if err != nil { log.Panic(err) } bot.Debug = true log.Printf(\u0026#34;Authorized on account %s\u0026#34;, bot.Self.UserName) u := tgbotapi.NewUpdate(0) u.Timeout = 60 updates := bot.GetUpdatesChan(u) for update := range updates { if update.Message == nil { // ignore non-Message updates  continue } msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text) switch update.Message.Text { case \u0026#34;open\u0026#34;: msg.ReplyMarkup = numericKeyboard case \u0026#34;close\u0026#34;: msg.ReplyMarkup = tgbotapi.NewRemoveKeyboard(true) } if _, err := bot.Send(msg); err != nil { log.Panic(err) } } }"},{"uri":"https://go-telegram-bot-api.github.io/examples/","title":"Examples","tags":[],"description":"","content":" Here are a few examples to get you on your way.\nBasic Usage  Reply Bot Commands  Bot-specific Telegram features  Simple Keyboard  "},{"uri":"https://go-telegram-bot-api.github.io/getting-started/frameworks/","title":"Further reading","tags":[],"description":"","content":" Libraries that build on features There are a number of frameworks that extend the features present in this library.\n finch \u0026mdash; Command based framework that makes it easy to build large projects. Others! Please open a pull request if you know of any other frameworks.  "},{"uri":"https://go-telegram-bot-api.github.io/_footer/","title":"","tags":[],"description":"","content":"Last updated 2018-10-09\n"},{"uri":"https://go-telegram-bot-api.github.io/","title":"","tags":[],"description":"","content":" go-telegram-bot-api Welcome to the documentation on telegram-bot-api.\nAt the time of writing, v5 is not yet released. There are a number of backwards incompatible changes. Some of the provided examples may not work correctly on older versions. For more information on the breaking changes, please see Migrating from V4.\nIf you\u0026rsquo;re looking for how to get started, please check out the Getting Started page.\n"},{"uri":"https://go-telegram-bot-api.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://go-telegram-bot-api.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]
